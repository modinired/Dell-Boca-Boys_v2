"""
Simple workflow execution engine for the Dell Boca Vista Boys platform.

This module provides a minimal runtime for executing workflow
definitions generated by the AI agents.  It is inspired by the n8n
data model but is intentionally independent of n8n.  The goal is to
enable true end‑to‑end automation without relying on external
orchestration tools.  Each workflow consists of a list of nodes
connected by directed edges.  A node specifies its type (e.g.
``webhook``, ``function``, ``set``, ``if``, ``httpRequest``, etc.) and
optional parameters.  When executed, the engine traverses the
connections starting from a designated ``webhook`` node and applies
each node’s behaviour to a shared context.

Only a subset of node types are supported out of the box:

* ``webhook`` – the starting point of the workflow.  It forwards the
  provided input data to the next node unmodified.
* ``set`` – injects static values into the context.  Its parameters
  follow the n8n format: ``{"values": {"string": [{"name": "foo",
  "value": "bar"}, ...]}}``.
* ``function`` – executes arbitrary Python code defined in the
  ``functionCode`` parameter.  The code must return a list of items,
  each with a ``json`` attribute.  The first item's ``json`` is
  merged back into the context.
* ``if`` – evaluates a boolean expression and chooses the next node
  based on the result.  String conditions follow n8n semantics: each
  condition dictionary has ``value1``, ``operation`` and ``value2``.
* ``httpRequest`` – performs an HTTP request using the ``requests``
  library.  It supports ``GET`` and ``POST`` with JSON bodies.  The
  response JSON (if any) is stored under ``response`` in the context.

Additional node types can be implemented by extending the
``_execute_node`` method.

The engine is intentionally simple: it runs nodes sequentially,
handling branching via ``if`` nodes.  Loops and concurrency are not
implemented.  Error handling is basic; exceptions within a node stop
execution and are reported via ``WorkflowExecutionError``.

"""

from __future__ import annotations

import json
from dataclasses import dataclass
from typing import Any, Dict, List, Optional
import requests


class WorkflowExecutionError(Exception):
    """Raised when an error occurs during workflow execution."""


@dataclass
class WorkflowNode:
    """Representation of a single workflow node."""
    id: str
    type: str
    name: str
    parameters: Dict[str, Any]


class WorkflowEngine:
    """Execute a workflow defined by nodes and connections."""

    def __init__(self, workflow_def: Dict[str, Any]) -> None:
        self.nodes: Dict[str, WorkflowNode] = {
            n['id']: WorkflowNode(
                id=n['id'],
                type=n['type'],
                name=n.get('name', n['id']),
                parameters=n.get('parameters', {})
            )
            for n in workflow_def.get('nodes', [])
        }
        self.connections: List[Dict[str, str]] = workflow_def.get('connections', [])

    def run(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the workflow starting from a ``webhook`` node.

        The ``input_data`` dictionary is stored under ``context['json']``.
        At each node, the engine updates the context based on the node
        type and parameters, then follows the outgoing connection to the
        next node.  If no connection exists, execution stops and the
        context is returned.
        """
        # Find starting node (webhook) or fallback to first node
        start_id: Optional[str] = None
        for node in self.nodes.values():
            if node.type.endswith('.webhook'):
                start_id = node.id
                break
        if start_id is None and self.nodes:
            start_id = next(iter(self.nodes))

        if start_id is None:
            raise WorkflowExecutionError("Workflow has no nodes")

        context: Dict[str, Any] = {'json': input_data.copy()}
        current_id: Optional[str] = start_id
        visited: set[str] = set()
        while current_id:
            if current_id in visited:
                raise WorkflowExecutionError(f"Detected cycle at node {current_id}")
            visited.add(current_id)
            node = self.nodes.get(current_id)
            if node is None:
                raise WorkflowExecutionError(f"Missing node {current_id}")
            # Execute node
            try:
                self._execute_node(node, context)
            except Exception as e:
                raise WorkflowExecutionError(f"Error in node {node.name}: {e}")
            # Determine next node via connections
            next_id = None
            for conn in self.connections:
                if conn['source'] == current_id:
                    # If this connection has an output condition (e.g. 'true'/'false'),
                    # evaluate the last boolean result stored in context
                    output_label = conn.get('output')
                    if output_label:
                        last_result = context.get('_last_condition_result')
                        # Continue only if the label matches the result
                        if str(last_result).lower() == output_label.lower():
                            next_id = conn['target']
                            break
                    else:
                        next_id = conn['target']
                        break
            current_id = next_id
        return context

    def _execute_node(self, node: WorkflowNode, context: Dict[str, Any]) -> None:
        """Execute a single node and update the context accordingly."""
        node_type = node.type
        params = node.parameters or {}
        if node_type.endswith('.webhook'):
            # The webhook simply forwards the input context
            return
        elif node_type.endswith('.set'):
            # Inject static values into the context
            values = params.get('values', {})
            strings = values.get('string', [])
            for item in strings:
                name = item.get('name')
                value = item.get('value')
                if name:
                    context['json'][name] = value
        elif node_type.endswith('.function'):
            # Execute arbitrary function code; expect a list of items
            code = params.get('functionCode', '')
            items = [{'json': context['json'].copy()}]
            local_ns = {'items': items}
            exec(code, {}, local_ns)  # Dangerous if untrusted!
            result_items = local_ns.get('items', [])
            if result_items:
                context['json'] = result_items[0].get('json', context['json'])
        elif node_type.endswith('.if'):
            # Evaluate condition: currently supports simple string equality
            conditions = params.get('conditions', {}).get('string', [])
            result = True
            for cond in conditions:
                v1 = cond.get('value1')
                op = cond.get('operation')
                v2 = cond.get('value2')
                # Resolve variables starting with {{$json.xxx}}
                def resolve(val: Any) -> Any:
                    if isinstance(val, str) and val.startswith('{{'):
                        expr = val.strip('{} ')
                        if expr.startswith('$json.'):
                            key = expr[len('$json.'):]
                            return context['json'].get(key)
                    return val
                lv1 = resolve(v1)
                lv2 = resolve(v2)
                if op == 'equals':
                    result = result and (lv1 == lv2)
                else:
                    raise WorkflowExecutionError(f"Unsupported operation {op}")
            context['_last_condition_result'] = result
        elif node_type.endswith('.httpRequest'):
            url = params.get('url')
            method = params.get('method', 'GET').upper()
            json_params = params.get('jsonParameters', False)
            if not url:
                raise WorkflowExecutionError("HTTP request node missing URL")
            if method == 'GET':
                resp = requests.get(url, timeout=10)
            elif method == 'POST':
                body = context['json'] if json_params else None
                resp = requests.post(url, json=body, timeout=10)
            else:
                raise WorkflowExecutionError(f"Unsupported HTTP method {method}")
            try:
                context['json']['response'] = resp.json()
            except Exception:
                context['json']['response'] = resp.text
        elif node_type.endswith('.emailSend'):
            subject = params.get('subject', '')
            text = params.get('text', '')
            print(f"[EmailSend] Subject: {subject}\n{text}")
        else:
            raise WorkflowExecutionError(f"Unsupported node type {node_type}")